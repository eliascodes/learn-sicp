; Exercise 1.14.

(define (count-change amount)
  (cc amount 5))
(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (= kinds-of-coins 0)) 0)
        (else (+ (cc amount
                     (- kinds-of-coins 1))
                 (cc (- amount
                        (first-denomination kinds-of-coins))
                     kinds-of-coins)))))
(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))

; Draw the tree illustrating the process generated by the count-change procedure
; of section 1.2.2 in making change for 11 cents.
;
; (cc 11 5) (cc -41 5) (0)
;           (cc 11 4)  (cc -14 4) (0)
;                      (cc 11 3)  (cc 1 3)  (cc 1 2)  (cc 1 1)  (cc 1 0) (0)
;                                                               (cc 0 1) (1)
;                                                     (cc -4 1) (0)
;                                           (cc -9 3) (0)
;                                 (cc 11 2) (cc 11 1) (cc 11 0) (0)
;                                                     (cc 10 1) (cc 10 0) (0)
;                                                               (cc 9 1)  (cc 9 0) (0)
;                                                                         (cc 8 1) (cc 8 0) (0)
;                                                                                  (cc 7 1) (cc 7 0) (0)
;                                                                                           (cc 6 1) (cc 6 0)  (0)
;                                                                                                    (cc 5 1)  (cc 5 0) (0)
;                                                                                                              (cc 4 1) (cc 4 0) (0)
;                                                                                                                       (cc 3 1) (cc 3 0) (0)
;                                                                                                                                (cc 2 1) (cc 2 0) (0)
;                                                                                                                                         (cc 1 1) (cc 1 0) (0)
;                                                                                                                                                  (cc 0 1) (1)
;                                           (cc 6 2)  (cc 6 1)  (cc 6 0)  (0)
;                                                               (cc 5 1)  (cc 5 0) (0)
;                                                                         (cc 4 1) (cc 4 0) (0)
;                                                                                  (cc 3 1) (cc 3 0) (0)
;                                                                                           (cc 2 1) (cc 2 0) (0)
;                                                                                                    (cc 1 1) (cc 1 0) (0)
;                                                                                                             (cc 0 1) (1)
;                                                     (cc 1 2)  (cc 1 1)  (cc 1 0) (0)
;                                                                         (cc 0 1) (1)
;                                                               (cc -4 2) (0)
;
; Sum of leaf nodes = 4

; prints Value: 4
(count-change 11)

; What are the orders of growth of the space and number of steps used by this
; process as the amount to be changed increases?
;
; The `cc` procedure calls itself twice recursively. It is a tree recursive
; process, and therefore, the order of growth of the space is proportional to
; the maximum depth of the tree, and the order of growth of the steps required
; is proportional to the number of nodes.
;
; Because the procedure `cc` is calls itself each time decreasing one of its
; arguments, and the terminating condition is when one or both of its arguments
; are less than or equal to 0, we know that the deepest branch will be that
; where first one argument is decremented to zero, and then the other. So the
; maximum depth of (cc n 5) will be n + 5 + 1, where the extra `+1` accounts for
; the final leaf nodes. For large n, we may say that the order of growth is
;
; R_space(n) = O(n)
;
; A tree-recursive procedure whose depth is equal to n and whose nodes each
; generate two child nodes will have a total number of nodes equal to
; 2^(n+1) - 1. However, the tree-recursive process defined by `cc` terminates
; many of its branches long before they reach the maximum depth. Therefore the
; value of 2^(n+1) - 1 is an upper bound. For large n, we may simplify this to
; 2^n.
;
; R_steps(n) = O(2^n)
